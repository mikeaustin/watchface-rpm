#include <pebble.h>
  
static Window *main_window;
static Layer *guage_layer;

//static TextLayer *time_layer;
static TextLayer *date_layer;
//static BitmapLayer *image_layer;
//static GBitmap *image_bitmap;

static GPath *s_my_path_ptr;

int angle;

static void update_time()
{
    time_t temp = time(NULL); 
    struct tm *tick_time = localtime(&temp);
 
    static char date_buffer[] = "Fri, Dec 31";

    // Update Date Layer

    strftime(date_buffer, sizeof(date_buffer), "%a, %b %d", tick_time);
    snprintf(date_buffer + 9, sizeof(date_buffer), "%d", tick_time->tm_mday);

    text_layer_set_text(date_layer, date_buffer);
}

GPoint pointForAngle(int angle, int radius)
{
    return (GPoint) { sin_lookup(angle) * radius / TRIG_MAX_RATIO, -cos_lookup(angle) * radius / TRIG_MAX_RATIO };
}

void my_layer_update_proc(Layer *my_layer, GContext *ctx)
{
    GRect frame = layer_get_frame(my_layer);
    GPoint center = GPoint(frame.size.w / 2, frame.size.h / 2);

    // Draw Minor Ticks

    graphics_context_set_stroke_color(ctx, GColorWhite);
    graphics_context_set_stroke_width(ctx, 1);

    //for (int i = -120; i <= 120; i += 1)
    for (int i = -128; i <= 128; i += 1)
    {
        int angle = TRIG_MAX_ANGLE * (i / 360.0);

        graphics_context_set_stroke_color(ctx, GColorWhite);

        if (i >= 80)
        {
            graphics_context_set_stroke_color(ctx, GColorRed);
            graphics_context_set_stroke_width(ctx, 2);
        }

        if (i % (256 / 8) == 0)
        {
            // Draw Major Ticks

            //graphics_context_set_stroke_color(ctx, GColorWhite);
            graphics_context_set_stroke_width(ctx, 2);

            GPoint p = pointForAngle(angle, 60), p2 = pointForAngle(angle, 70);
            graphics_draw_line(ctx, GPoint(p.x + center.x, p.y + center.y), GPoint(p2.x + center.x, p2.y + center.y));
        }
        else if (i % (256 / 16) == 0)
        {
            // Draw Half Major Ticks

            //graphics_context_set_stroke_color(ctx, GColorWhite);
            graphics_context_set_stroke_width(ctx, 2);

            GPoint point2 = (GPoint) { sin_lookup(angle) * 62 / TRIG_MAX_RATIO + 144 / 2, -cos_lookup(angle) * 62 / TRIG_MAX_RATIO + frame.size.h / 2 };
            GPoint point = (GPoint) { sin_lookup(angle) * 70 / TRIG_MAX_RATIO + 144 / 2, -cos_lookup(angle) * 70 / TRIG_MAX_RATIO + frame.size.h / 2 };

            graphics_draw_line(ctx, point2, point);
        }
        else if (i % (256 / 32) == 0)
        {
            // Draw Minor Ticks

            //graphics_context_set_stroke_color(ctx, GColorWhite);
            graphics_context_set_stroke_width(ctx, 1);

            GPoint point2 = (GPoint) { sin_lookup(angle) * 65 / TRIG_MAX_RATIO + 144 / 2, -cos_lookup(angle) * 65 / TRIG_MAX_RATIO + frame.size.h / 2 };
            GPoint point = (GPoint) { sin_lookup(angle) * 67 / TRIG_MAX_RATIO + 144 / 2, -cos_lookup(angle) * 67 / TRIG_MAX_RATIO + frame.size.h / 2 };

            graphics_draw_line(ctx, point2, point);
        }
    }

    // Draw Circle

    graphics_context_set_stroke_color(ctx, GColorWhite);
    graphics_context_set_stroke_width(ctx, 2);

    graphics_draw_circle(ctx, GPoint(144 / 2, frame.size.h / 2), 70);

    graphics_context_set_fill_color(ctx, GColorBlack);

//    gpath_draw_filled(ctx, s_my_path_ptr);
//    graphics_fill_rect(ctx, GRect(0, 144 - 30, 144, 30), 0, GCornerNone);

    // Draw Numbers

    for (int i = -128; i <= 128; i += 1)
    {
        if (i % 30 == 0)
        {
            int angle = TRIG_MAX_ANGLE * (i / 360.0);
            GPoint point3 = (GPoint) { sin_lookup(angle) * 50 / TRIG_MAX_RATIO + 144 / 2, -cos_lookup(angle) * 50 / TRIG_MAX_RATIO + frame.size.h / 2 };

            char buffer[2];
            snprintf(buffer, sizeof(buffer), "%d", (i + 120) / 30);
            GSize size = graphics_text_layout_get_content_size(buffer, fonts_get_system_font(FONT_KEY_GOTHIC_18_BOLD), GRect(point3.x, point3.y, 30, 20),
                                                               GTextOverflowModeWordWrap, GTextAlignmentCenter);
            graphics_draw_text(ctx, buffer, fonts_get_system_font(FONT_KEY_GOTHIC_18_BOLD), GRect(point3.x - size.w / 2, point3.y - size.h / 2 - 2, size.w, size.h),
                                                                  GTextOverflowModeWordWrap, GTextAlignmentCenter, NULL);
        }
    }

    // Draw Meter

    GPoint pp = pointForAngle(TRIG_MAX_ANGLE * ((30 - 90) / 360.0), 2);
    GPoint p = pointForAngle(TRIG_MAX_ANGLE * (angle++ / 360.0), 67);
    graphics_context_set_stroke_color(ctx, GColorOrange);
    graphics_context_set_stroke_width(ctx, 2);

    graphics_draw_line(ctx, GPoint(pp.x + 144 / 2, pp.y + frame.size.h / 2), GPoint(p.x + 144 / 2, p.y + frame.size.h / 2));
    graphics_draw_line(ctx, GPoint(-pp.x + 144 / 2, -pp.y + frame.size.h / 2), GPoint(p.x + 144 / 2, p.y + frame.size.h / 2));
    //graphics_draw_line(ctx, GPoint(144 / 2, 168 / 2 - 12), GPoint(p.x + 144 / 2, p.y + 168 / 2 - 12));

    graphics_context_set_stroke_color(ctx, GColorDarkGray);
    graphics_context_set_stroke_width(ctx, 1);
    graphics_draw_circle(ctx, GPoint(144 / 2, frame.size.h / 2), 10);

    graphics_context_set_stroke_color(ctx, GColorBlack);
    graphics_fill_circle(ctx, GPoint(144 / 2, 168 / 2 - 12), 9);

    //update_time();
}

static const GPathInfo BOLT_PATH_INFO = {
    .num_points = 3,
    .points = (GPoint []) { {144 / 2, 144 / 2 - 0}, {144, 144 - 30}, {0, 144 - 30} }
};

static void main_window_load(Window *window)
{
    static GPoint points[360];
    for (int i = 0; i < 270; i += 1) {
        int angle = TRIG_MAX_ANGLE * (i / 360.0);
        points[i] = (GPoint) { sin_lookup(angle) * 72 / TRIG_MAX_RATIO, -cos_lookup(angle) * 72 / TRIG_MAX_RATIO }; 
    }

    static GPathInfo xBOLT_PATH_INFO = {
        .num_points = 3,
        .points = points
    };

    s_my_path_ptr = gpath_create(&BOLT_PATH_INFO);

    guage_layer = layer_create(GRect(0, 0, 144, 144));
    layer_set_update_proc(guage_layer, my_layer_update_proc);
    layer_add_child(window_get_root_layer(window), guage_layer);



    // Create Image Layer

    // image_bitmap = gbitmap_create_with_resource(RESOURCE_ID_IMAGE_BACKGROUND);
    // image_layer = bitmap_layer_create(GRect(0, 168 - 107, 144, 107));

    // bitmap_layer_set_bitmap(image_layer, image_bitmap);

    // layer_add_child(window_get_root_layer(window), bitmap_layer_get_layer(image_layer));

    // Create Time Layer

    // time_layer = text_layer_create(GRect(0, -5, 144, 50));

    // text_layer_set_background_color(time_layer, GColorClear);
    // text_layer_set_text_color(time_layer, GColorWhite);
    // text_layer_set_text(time_layer, "00:00");
    // text_layer_set_font(time_layer, fonts_get_system_font(FONT_KEY_BITHAM_42_LIGHT));
    // text_layer_set_text_alignment(time_layer, GTextAlignmentCenter);
 
    // layer_add_child(window_get_root_layer(window), text_layer_get_layer(time_layer));

    // Create Date Layer

    date_layer = text_layer_create(GRect(0, 40, 144, 20));

    text_layer_set_background_color(date_layer, GColorClear);
    text_layer_set_text_color(date_layer, GColorLightGray);
    //text_layer_set_text(date_layer, "Fri, Jul 3");
    text_layer_set_font(date_layer, fonts_get_system_font(FONT_KEY_GOTHIC_18));
    text_layer_set_text_alignment(date_layer, GTextAlignmentCenter);
 
    layer_add_child(window_get_root_layer(window), text_layer_get_layer(date_layer));

    // Make sure the time is displayed from the start

    //update_time();
}
 
static void main_window_unload(Window *window)
{
    text_layer_destroy(date_layer);

    //gbitmap_destroy(image_bitmap);
    //bitmap_layer_destroy(image_layer);
}

static void tick_handler(struct tm *tick_time, TimeUnits units_changed)
{
    update_time();
}

static void timer_handler(void *data)
{
    layer_mark_dirty(guage_layer);

    app_timer_register(0, timer_handler, NULL);
}

static void init()
{
    main_window = window_create();
 
    window_set_window_handlers(main_window, (WindowHandlers) {
        .load = main_window_load,
        .unload = main_window_unload
    });

    window_set_background_color(main_window, GColorBlack);
 
    window_stack_push(main_window, true);

    //tick_timer_service_subscribe(MINUTE_UNIT, tick_handler);
    app_timer_register(1, timer_handler, NULL);
}
 
static void deinit()
{
     window_destroy(main_window);
}
 
int main(void)
{
    init();
    app_event_loop();
    deinit();
}
